[{"content":"Teodor-Dumitru Ene will be presenting his work on adder optimisations, he\u0026rsquo;ll be covering:\n Prefix sums His research Adder-specific quirks and optimizations Future goals Questions!  Please join us:\n Tuesday, 10 May · 17:30 – 18:30 CEST Streaming on youtube  ","date":"2022-05-06T09:38:52+02:00","image":"http://blog.yosyshq.com/static-2022/adders.jpg","permalink":"http://blog.yosyshq.com/p/optimising-adders/","title":"Teodor-Dumitru and the Complexity of Adder Implementations in Hardware"},{"content":"Yosys is probably best known for providing synthesis for FPGA targets, but it\u0026rsquo;s a very flexible tool capable of a lot more.\nOpenLane, SiliconCompiler and Coriolis2 are 3 examples of open source ASIC flows, which has been an active field of development over the last year.\nWe\u0026rsquo;re very happy to see our tools get used in the first Google sponsored tapeouts, helping to make the world\u0026rsquo;s first chips made with an open source PDK, and open source all the way down to the designs.\nIf you want to find out more about what happened in the world of open source silicon in 2021, you can see our CSO Matt Venn\u0026rsquo;s recent presentation for Hackaday Remoticon here:\n  ","date":"2022-02-28T11:23:54+01:00","permalink":"http://blog.yosyshq.com/p/open-source-silicon-with-yosys/","title":"Open Source Silicon with Yosys"},{"content":"Code: https://github.com/YosysHQ-Docs/Blog-Async-Load-FFs\nPart 1: The Bad News We have recently added support for asynchronous load flip-flops to Yosys for a customer project. However, we consider this a problematic feature in a (System-)Verilog synthesis tool, and thus I’d like to take this opportunity to explain why one should avoid using asynchronous load flip-flops in new (System-)Verilog designs.\nWhat are asynchronous load flip-flops An asynchronous load flip-flop is a type of flip-flop with asynchronous reset for which the reset value is not a compile-time / synthesis-time constant.\nreg async_load_ff_q; wire async_load_ff_reset_val = \u0026lt;dynamic_expression\u0026gt;; always_ff @(posedge clock, posedge load) if (load) async_load_ff_q \u0026lt;= async_load_ff_reset_val; else async_load_ff_q \u0026lt;= ...; This distinguishes them from the more common asynchronous set (reset) flip-flops, for which the reset value is a compile-time (synthesis-time) constant.\nreg async_reset_ff_q; localparam async_reset_ff_reset_val = \u0026lt;constant_expression\u0026gt;; always_ff @(posedge clock, posedge reset) if (reset) async_reset_ff_q \u0026lt;= async_reset_ff_reset_val; else async_reset_ff_q \u0026lt;= ...; IEEE Std 1364.1-2002, the IEEE Standard for Verilog Register Transfer Level Synthesis, does allow such asynchronous load flip-flops in synthesis, but states that the synthesis results will only match the behavior of the original Verilog code under certain conditions.\nThe problem with Verilog and asynchronous load flip-flops The key insight is that the way an asynchronous reset is modelled using Verilog always blocks is not sensitive to the data signals providing the asynchronous load value. Thus, if the data signals are changing while the asynchronous reset is active, the new data is not loaded into the flip-flop when neither clock nor the asynchronous reset is toggling.\nConsider the following SystemVerilog design (dut.sv):\nmodule dut ( input clk1, clk2, arst, output reg [7:0] cnt1, cnt2 ); always_ff @(posedge clk1 or posedge arst) if (arst) cnt1 \u0026lt;= 0; // constant expression (async reset)  else cnt1 \u0026lt;= cnt1 + 7; always_ff @(posedge clk2 or posedge arst) if (arst) cnt2 \u0026lt;= cnt1; // dynamic expression (async load)  else cnt2 \u0026lt;= cnt2 + 11; endmodule And the following test bench (tb.sv):\nmodule tb; reg clk1 = 0, clk2 = 0, arst = 0; wire [7:0] cnt1, cnt2; dut dut (clk1, clk2, arst, cnt1, cnt2); task do_clk1; clk1 = 1; #5; clk1 = 0; #5; endtask task do_clk2; clk2 = 1; #5; clk2 = 0; #5; endtask task do_arst; arst = 1; #5; arst = 0; #5; `ifdef DOUBLE_ARST arst = 1; #5; arst = 0; #5; `endif endtask initial begin #10; do_arst; $display(cnt1, cnt2); repeat (5) do_clk1; $display(cnt1, cnt2); do_arst; $display(cnt1, cnt2, \u0026#34; \u0026lt;--\u0026#34;); repeat (5) do_clk2; $display(cnt1, cnt2); do_arst; $display(cnt1, cnt2); end endmodule Running it without and with -DDOUBLE_ARST produces the following output:\n$ make run0 iverilog -g2012 -o sim0 -s tb tb.sv dut.sv ./sim0 0 x 35 x 0 35 \u0026lt;-- 0 90 0 0 $ make run1 iverilog -g2012 -o sim1 -s tb -DDOUBLE_ARST tb.sv dut.sv ./sim1 0 0 35 0 0 0 \u0026lt;-- 0 55 0 0 In the first case with a single pulse on arst, the second counter is reset to the non-zero value of the first counter from before the reset pulse.\nBut a real-world asynchronous load flip-flop would of course behave like a transparent latch while the reset pulse is high, propagating the new (zero) value of the first counter to the second counter register. But this only happens in simulation when we pulse the reset signal a second time.\nThis can lead to non-trivial simulation-synthesis mismatches that are hard to debug, and may result in a chip that does not function as expected.\nThus, asynchronous load flip-flops should be avoided in (System)Verilog designs, or at least it should be formally verified that the asynchronous load value of such a flip-flop can never change while the reset signal is active.\nThis is in line with IEEE Std 1364.1-2002 requirements for sequential logic verification:\n When asynchronous data is assigned, the asynchronous data shall not change during the period in which the asynchronous control (the condition under which the data is assigned) is active.\nIEEE Std 1364.1-2002, Section 4.2\n It is worth noting that a similar problem exists with flip-flops that have both asynchronous set and reset: If both are asserted and then one is released after the other, the one that’s released later should take precedence over the one that’s released earlier. However, since the always block is not triggered by the falling edge of the set or reset signal, releasing just one of the two will have no effect on the flip-flop output. IEEE Std 1364.1-2002 also acknowledges this issue:\n The problem occurs when both reset and preset are asserted at the same time and reset is removed first. When reset is removed (posedge rst_n), the always block is not activated. This means that the output will continue to drive the reset output to ‘0’ until the next rising clock edge. A real flip-flop of this type would immediately drive the output to ‘1’ because the set_n signal is an asynchronous preset. This potentially could cause a mismatch between pre-synthesis and post-synthesis simulations using this model.\nIEEE Std 1364.1-2002, Appendix B.6\n Part 2: The Good News In this section we discuss different design methods that avoid the use of behavioral Verilog code to model asynchronous load FFs.\nInstantiate (Vendor) Primitives The best and easiest way of dealing with this issue is to instantiate FF primitives directly. This can either be vendor cells, or a user-defined module for which we chose different implementations for simulation and synthesis, one with correct simulation behavior, and one that is synthesizable, respectively.\nThe new DUT would look something like this (dut_myff.sv):\nmodule dut ( input clk1, clk2, arst, output reg [7:0] cnt1, cnt2 ); myff ff1[7:0] (cnt1, cnt1 + 8\u0026#39;d 7, clk1, arst, 8\u0026#39;h 00), ff2[7:0] (cnt2, cnt2 + 8\u0026#39;d 11, clk2, arst, cnt1); endmodule When instantiating a Vendor primitive one should always double-check that the vendor simulation library does model asynchronous loads correctly, for example using the techniques described in the next two sections.\nSimulation model using Verilog UDP Verilog UDP primitives can be used to correctly model the behavior of asynchronous load flip-flops. But UDPs are not synthesizable, so we need to also provide a synthesizable implementation of an asynchronous load flip-flop (myff_udp.sv):\n`ifdef SYNTHESIS module myff ( output reg q, input d, clk, arst, rval ); always @(posedge clk or posedge arst) if (arst) q \u0026lt;= rval; else q \u0026lt;= d; endmodule `else primitive myff (q, d, clk, arst, rval); input d, clk, arst, rval; reg q; output q; table // D C R V : Q : Q\u0026#39;  ? ? 1 0 : ? : 0 ; // async reset  ? ? 1 1 : ? : 1 ; // async set  0 p 0 ? : ? : 0 ; // posedge clock, d=0  1 p 0 ? : ? : 1 ; // posedge clock, d=1  ? n 0 ? : ? : - ; // negedge clock  * ? ? ? : ? : - ; // any data edge  ? ? * ? : ? : - ; // any arst edge  ? ? ? * : ? : - ; // any rval edge  endtable endprimitive `endif Running our test-bench now yields the expected result, even when we pulse the asynchronous load signal only once:\n$ make run2 iverilog -g2012 -o sim2 -s tb tb.sv dut_myff.sv myff_udp.sv ./sim2 0 0 35 0 0 0 \u0026lt;-- 0 55 0 0 Simulation model using procedural assign and deassign Another approach is to “fix up” the asynchronous load using procedural assign and deassign (myff_ada.sv):\nmodule myff ( output reg q, input d, clk, arst, rval ); always_ff @(posedge clk or posedge arst) if (arst) q \u0026lt;= rval; else q \u0026lt;= d; `ifndef SYNTHESIS always @(arst) if (arst) assign q = rval; else deassign q; `endif endmodule Running our test-bench on this version also yields the expected result:\niverilog -g2012 -o sim3 -s tb tb.sv dut_myff.sv myff_ada.sv ./sim3 0 0 35 0 0 0 \u0026lt;-- 0 55 0 0 Of course it’s also possible to use procedural assign and deassign directly in the design to “fix up” the behavior of asynchronous load flip-flops (dut_ada.sv):\nmodule dut ( input clk1, clk2, arst, output reg [7:0] cnt1, cnt2 ); always_ff @(posedge clk1 or posedge arst) if (arst) cnt1 \u0026lt;= 0; else cnt1 \u0026lt;= cnt1 + 7; always_ff @(posedge clk2 or posedge arst) if (arst) cnt2 \u0026lt;= cnt1; else cnt2 \u0026lt;= cnt2 + 11; `ifndef SYNTHESIS always @(arst) if (arst) assign cnt2 = cnt1; else deassign cnt2; `endif endmodule However, sprinkling procedural assign and deassign statements and ifndef-SYNTHESIS-blocks all over the design is much more error prone than implementing this work-around only once in a custom cell type that can then be instantiated wherever needed.\nThe latch+flip-flop trick The following technique is used on some FPGA architectures to emulate asynchronous-load flip-flops using latches and asynchronous-reset flip-flops only. It can be used to completely avoid asynchronous-load FFs while preserving the semantic of such elements (myff_hack.sv):\nmodule myff ( output q, input d, clk, arst, rval ); // a latch to store the async-load value  reg latched_rval; always @* if (arst) latched_rval = rval; // a regular FF to store the clocked data value  reg q_without_reset; always @(posedge clk) q_without_reset \u0026lt;= d; // an asynchronous-reset flip-flop to remember last event  reg last_event_was_clock; always @(posedge clk or posedge arst) if (arst) last_event_was_clock \u0026lt;= 0; else last_event_was_clock \u0026lt;= 1; // output either the latched reset value or clocked data value  assign q = last_event_was_clock ? q_without_reset : latched_rval; endmodule Running our test-bench a last time gives the expected result for this solution as well:\niverilog -g2012 -o sim5 -s tb tb.sv dut_myff.sv myff_hack.sv ./sim5 0 0 35 0 0 0 \u0026lt;-- 0 55 0 0 This is a useful last resort solution for designs that absolutely require asynchronous-load flip-flop semantics, and where the risks associated with using different synthesis and simulation models for such a component are not acceptable.\n","date":"2021-11-30T00:00:00Z","image":"http://blog.yosyshq.com/static-2021/asyncff.png","permalink":"http://blog.yosyshq.com/p/async-load-ff/","title":"Why Asynchronous Load Flip-Flops Should Be Avoided"},{"content":"YosysHQ are pleased to announce a new pricing option for small companies with one full time engineer.\nFor just €500 per month (excl. VAT), you can get our ‘Solo bundle’:\n 2 nodes of TabbyCAD Suite, offering industry compatible language support and our formal verification tools and verification IP. Unlimited number of users/processes per node. (Up to 32 CPUs per node.) Not time limited, use in your continuous integration systems. Support that includes potential for custom work and access to our technical team.  For two full time engineers, we have our ‘Solo bundle plus’ which adds another 2 TabbyCAD nodes for an additional €400 per month.\nWe also have competitive prices for larger teams.\nFor an evaluation license, or to discuss your requirements further please contact us at contact@yosyshq.com.\n","date":"2021-07-26T15:35:40+02:00","permalink":"http://blog.yosyshq.com/p/pricing-for-small-companies/","title":"New pricing for small companies"},{"content":"This Application Note was written with the intention of showing a brief introduction to SVA, and is definitely not a substitute for extensive training. To learn more about formal verification and SVA, it is recommended to book the course given by the FPV specialists at YosysHQ.\n A brief history of SystemVerilog Assertions SVA layers definition and examples Assertion types, sequential property operators A short description of liveness and safety properties Practical examples using the sequence builder module written by our CTO Claire Xen.  https://yosyshq.readthedocs.io/projects/ap109\nFeel free to give us feedback and suggest new topics.\n","date":"2021-07-07T12:37:04+02:00","permalink":"http://blog.yosyshq.com/p/ap109/","title":"App Note 109"},{"content":"For a long time people have asked us for quality long form content that shows how to get the best from our formal tools.\nWe have started a series of app notes, with the first being about cover and witness for SVA properties. Otherwise known as \u0026lsquo;Am I testing what I think I\u0026rsquo;m testing\u0026rsquo;!\nWhat You will learn in this app note:\n Default clocking and default disable declarations Sequences and cycle delays Overlapping and non-overlapping implication syntax and semantic Weak precondition cover and witness How to apply that to a practical HDL code example  https://yosyshq.readthedocs.io/projects/ap120\nFeel free to give us feedback and suggest new topics.\n","date":"2021-05-20T14:04:45+02:00","permalink":"http://blog.yosyshq.com/p/ap120/","title":"App Note 120"},{"content":"YosysHQ.com is the new home for the team maintaining Yosys and the related Open Source EDA projects, and the commercial products and services we offer.\nOur team is led by N. Engelhardt as CEO, Claire Wolf as CTO, and Matt Venn as CSO. We are looking to work with more people, so feel free to contact us: contact@yosyshq.com\nTabby CAD Suite is a bundle of our well-known Open Source EDA software packages, combined with additional components that allow seamless integration of our tools in typical industrial digital design environments.\nWe also provide support and training for users of our Tabby CAD Suite package and for developers building their work on top of our open source projects.\nIn addition, we welcome opportunities to get involved with new projects large and small. We are looking to grow our collaborations with industry and academic partners on improving and expanding our synthesis, place and route, and formal verification flows.\nWe look forward to a positive relationship with the Open Source EDA community and external partners.\nMake sure you visit our website www.yosyshq.com and send us an email or tweet at us @YosysHQ to say hi!\n","date":"2021-02-08T00:00:00Z","permalink":"http://blog.yosyshq.com/p/hello/","title":"Hello World!"}]